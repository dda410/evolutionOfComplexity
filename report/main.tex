% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
\usepackage[toc,page]{appendix}
\usepackage{listings}
\usepackage{color}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
%  frame=single,
  breaklines=true,
}

% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
%
\title{Cooperative and Selfish Groups Evolvability}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Dimitri Diomaiuta}
%
% \authorrunning{F. Author et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{University of Southampton}
%% \institute{Princeton University, Princeton NJ 08544, USA \and
%% Springer Heidelberg, Tiergartenstr. 17, 69121 Heidelberg, Germany
%% \email{lncs@springer.com}\\
%% \url{http://www.springer.com/gp/computer-science/lncs} \and
%% ABC Institute, Rupert-Karls-University Heidelberg, Heidelberg, Germany\\
%% \email{\{abc,lncs\}@uni-heidelberg.de}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
In this paper we analyze and reproduce the experiments discussed in
the paper \textit{Individual
Selection For Cooperative Group Formation} \cite{groups}. In the first
part of this paper we discuss and reimplement the model described in
\cite{groups} that aims at evolving cooperative and selfish traits. In
the second part we extend the paper by applying the niche construction
process to the time spent reproducing in groups parameter.
%\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}
%
%
%

\section{Introduction}
The biological inspiration of the research is bacteria growth. In this
biological scenario we can observe the different types of bacteria,
that under limited resources they behave in a cooperative way (growing
slower and consuming less) or in a selfish one (growing faster and
consuming more resources).
The originality of \textit{T. Powers} research \cite{groups} lies in
the fact that cooperation is not favoured by environmental
conditions. Techniques like spatially structured population, described
in \cite{b1,b2,b3,b5}, or not sharing resources with the rest of the
population are avoided. Another approach that is avoided in the
paper is the trait group aggregation shown in \cite{b6,b7,b8}. Trait
group aggregation favours the cooperators by exploiting the
differential group productivity. Other environmental settings that
facilitates the growth of the cooperative trait is shown in
\cite{b7,b8,b9}. Here the individuals with similar genetic traits are
grouped together, promoting the cooperative trait. The main research
point of the paper is, hence, to observe which genetic trait will
emerge when environmental conditions that favours cheaters or
cooperator are evolved as well.

The technique used to evolve the environmental settings is the niche
construction \cite{b10}. The model is composed by individuals that
specify two genetic traits:
\begin{itemize}
\item Strategy trait: cooperative or selfish
\item Group size trait: large or small
\end{itemize}
Following the settings of the model we can see that there are four
different kind of individuals: \textit{Cooperative + Large},
\textit{Cooperative + Small}, \textit{Selfish + Large} and
\textit{Selfish + Small}.
The model settings favours large groups, having a larger assigned
resource, and selfish ones, having a faster growth rate. This may to
\textit{Selfish + large} to win over the other species. Instead, when
all the four possible individual types are present, we can observe
\textit{Cooperative + Small} reaching fixation.

\section{Model Details}
We describe in this section the settings of the model we
reproduced. As Powers describes \cite{groups} the model has a
population of size N where the 4 types of individuals have, initially,
an equal distribution. The strategy genotype specifies the amount of
resources that and individual consumes and its growth rate. The group
size genotype specifies the type of group that the individual will be
part of. After the initialization phase the main routine of the
program starts. In this routine the individuals of the initial
population are in one group, called migrant pool. The second phase,
called aggregation, corresponds to randomly divide individuals into
groups according to their group size genotype, discarding the
unassigned individuals. The third phase is about performing reproduction
within the groups, as described in subsection \ref{repr}. In Powers'
model reproduction occurs only within groups for $t$ generations. After the reproduction
step the offspring joins again the migrant pool, this is the fourth
step. The last step is about rescaling the population back to its
original size N. This is done by maintaining the proportion between
the individuals. This routine continues for $T$ generations.

\subsection{reproduction step}\label{repr}
Reproduction, in this model, depends on $R$, a limited resource influx
that each group is given. The amount of resource depends on the group
size. Large groups have a 5\% per capita more resource than their
smaller counterpart. Reproduction, in this model, happen asexually and
the offspring are not affected by mutation. The offspring size for
each individual type is determined only by the consumption and growth rate
of their parents given a limited resource influx and the distribution
of other individuals inside their group. The amount of $R$ that
each genotype receives is given by equation \ref{rshare}.
\begin{equation}\label{rshare}
r_i = \frac{n_i G_i C_i}{\sum_{j} (n_j G_j C_j)}
\end{equation}
The genotype $i$ receives $r_i$ resource share. $n_i$ represents the
number of individuals of genotype $i$ in the current generation and
$G_i$ and $C_i$ represents respectively the growth and consumption
rate. At the denominator, genotype $j$ represents all the other
genotypes, $i$ included. Given the resource share of a genotype for a
given group, its offspring size is determined by the replicator equation \ref{offspring}.
\begin{equation}\label{offspring}
n_i(t + 1) = n_i(t) + \frac {r_i}{C_i} - Kn_i(t)
\end{equation}
The current generation is represented by $t$. The replicator equation
\ref{offspring} introduces also a constant mortality term represented by $K$.

\section{Implementation reproduction}
In this section we discuss the reimplementation of Powers' research
\cite{groups} and the results we obtained.

\subsection{Implementation details}
The first step towards reproduction was to gather all the parameters
used throughout the paper. We were able to reproduce the paper using
the exact same parameter used by Powers. The parameters that were
missing from the original paper, like the resource share assigned to
the groups and the death rate, were given by the University of
Southampton through assignment specifications. Table
\ref{tab_parameters} contains all the parameters used for our
reimplementation.
\begin{table}
\caption{The parameters settings of our reproduced model.}\label{tab_parameters}
\begin{tabular}{|l|r|}
\hline
\textbf{Parameters}~~~ & \textbf{Value}~~~ \\
\hline
Growth rate (cooperative), $G_c$ & 0.018 \\
\hline
Growth rate (selfish), $G_s$ & 0.02 \\
\hline
Consumption rate (cooperative), $C_c$ & 0.1 \\
\hline
Consumption rate (selfish), $C_s$ & 0.2 \\
\hline
Population size, $N$ & 4000 \\
\hline
Number of generations, $T$ & 1000 \\
\hline
Small group size & 4 \\
\hline
Large group size & 40 \\
\hline
Small group resource & 4 \\
\hline
Large group resource & 50 \\
\hline
Number of generations within group $t$ & 4 \\
\hline
Death rate $K$ & 0.1 \\
\hline
\end{tabular}
\end{table}
The program we reimplemented consists of four Java classes. The
\textit{Individual} object (see code at appendix \ref{ind}) contains the two
genotypes and is used to represents the bacteria. The
\textit{IndividualFrequencies} object (see code at appendix \ref{indfre})
represents the frequencies for a given individual type (among the four
possible types). The \textit{GroupFrequencies} (see code at appendix
\ref{groupfre}) describes the frequencies of all the four types for a
given aggregation. Lastly, the \textit{Main} class of the program (see
code at appendix \ref{main}) is responsible for the aggregation in
groups, the reproduction, the dispersal and the
normalization steps. We reimplemented the resource allocation
(\ref{rshare}) and the replicator equation (\ref{offspring}) exactly
how reported in the original paper. The only relevant implementation
choice that we took independently from the original paper, due to not
appearing in Powers' paper, was the rounding of the offspring. Since
the replicator equation (\ref{offspring}) was not producing integers,
after some testing, we decided to round the offspring during the
normalization step.

\section{random}
\subsection{Genetic algorithm}
As already anticipated, this algorithm works by creating a fixed size population
of random board configurations. Each of these board configuration is
assigned a fitness value to evaluate how close to the goal the
solution is. In this specific case the fitness function calculates the
sum of the receiving attacks for each queen, see equation \ref{fitness}. 
\begin{equation} \label{fitness}
\sum_{i=1}^{N} attacksForQueen(Q_i)
\end{equation}
The configurations with a smaller fitness values are the ones
performing better and hence the one with a better queen
placement. After initializing the boards population the algorithm
starts its main routine. First two parents are selected from the population. The
first one is selected between the best one of two random individuals
in the population, and so is the second one. Second a new individual
is created via sexual reproduction of the two selected parents. Each
queen acts like a genotype of the board. The reproduction follows
uniform crossover, hence, each of the parents genotype has 50\%
probability to be transmitted to the offspring. After the reproduction
has completed a new board configuration is created. The third step is
mutation. At this step each genotype of the new board has a certain
probability to mutate and change in one of the possible values. The
probability of mutation is 1/N. In other words one queen of the new board
will randomly move in its column. The fourth and last step is to put
the offspring back into the population. This is done by selecting two
individuals at random from the population and substitute the less fit
one with the new board. This process is repeated until a goal solution
is found (there are no more queens attacking each other).

\subsection{Min-conflict algorithm}
The min-conflict algorithm works by reducing the problem to a
constraint satisfaction one. A \textit{CSP} describes a problem as a
set of variables and constraints \cite{russel2016artificial}. Every
variable has a value and the goal is reached when none of the values
break the constraints. In the N-queens problem the variables are the queens and
the set of values the position in their column. The constraints are
that non of the queens should be under attack by another one. The
algorithm initializes one single board and then enters its main
routine. The routine selects a conflicting variable at random, in this
case a queen, and assigns to it the value that minimizes the
conflicts. This step is repeated until all constraints are satisfied
and, hence, a solution is found.

\section{Implementation}
The source code has been implemented in python. A library from the
University of Southampton containing the code to represent the
N-queens board has been used. The implementation of the min-conflict
algorithm followed the pseudo-code given by chapter 6 of
\cite{russel2016artificial}. The implementation of the genetic
algorithm followed some key ideas from chapter 4 of
\cite{russel2016artificial} but it differs in the reproduction
step. We have implemented it with uniform crossover instead of one
point crossover. The population size, after some testing, has been
fixed to 10 times the number of queens. Both algorithms have been
implemented in their own classes providing modularity for the testing
phase. They can be executed on different sizes of the N-queens
board. The two algorithms were tested on different input sizes and the
results averaged on 10 different runs in order to remove the
randomness provided by the board initialization. The evaluation
metrics of the algorithms is the number of steps taken to reach the
solution. In the case of the genetic algorithm every time a new board
is created the number of step increases. In the case of the
min-conflict one the step count increases every time a new conflicting
variable is picked. The source code of the genetic algorithm, the
min-conflict algorithm and the testing script can be respectively found in appendix
\ref{genetic}, \ref{minconflict}, \ref{testing}.

\section{Results}
In this section we analyze the results obtained by testing the two
algorithms with different boards sizes. Table \ref{tab_nqueens}
contains the results of the two algorithms, see appendix
\ref{appendixB} for the complete output of the program.
\begin{table}
\caption{The results of the two algorithms.}\label{tab_nqueens}
\begin{tabular}{|r|r|r|}
\hline
\textbf{Board Size}~~~ & \textbf{Genetic Algorithm}~~~ &
\textbf{Min-conflict Algorithm}~~~ \\
\hline
5 & 79 & 4 \\
\hline
6 & 38503 & 22 \\
\hline
7 & 3516 & 8 \\
\hline
8 & 11222 & 39 \\
\hline
9 & 127917 & 46 \\
\hline
10 & 265690 & 110 \\
\hline
11 & 143654 & 119 \\
\hline
\end{tabular}
\end{table}
As reported by the experiments, the min-conflict algorithm is
performing better than the genetic one by 2 or 3 orders of
magnitude. We can also observe a linear growth in the genetic
algorithms while the min-conflict one is less affected by the size of
the board. This is justified by the fact that min-conflict algorithm
is well known for being incredibly effective on CSP problems and its
time complexity almost independent of problem size \cite{russel2016artificial}. Another important
observation is that the initial board configuration plays an important
role in the algorithm execution. The obtained results support this
claim, as we can see the number of steps when the board size is 7. In
this case both algorithms take considerably less than the previous
step. A board size of 7 probably facilitates to have an easier to
solve initial state and hence the number of steps to obtain the
results are lower. For the same reason the implemented genetic
algorithm has generally a worse performance. Having more boards initialized
randomly makes the algorithm more subjective to difficult
configurations. The genotypes of these configurations will be passed
to the offspring and, hence, the algorithm will take more steps to
make them extinguish.

On a more general analysis we can see that both algorithms find the
optimal solution and, hence, are complete. In the genetic algorithm
case this happens because the fitness landscape has one global optimum
that is constituted by a board with no queen attacking each other. Via
reproduction and mutations the algorithm will eventually converge and
find the optimal solution. The same reasoning applies to the
min-conflict algorithm. Selecting the conflicting vertices in an
iterative way and assigning to them the value that gives the minimum
conflict will eventually make the board to converge to the optimal
one.


\section{Limitations and future work}
The reproduction step in the genetic algorithm needs further research
in order to select the most effective technique for the N-queens
problem. Comparing the performances of uniform crossover, one-point crossover, as
described in \cite{russel2016artificial}, and k-point crossover can be
a starting point.

Another interesting addition is the introduction of metaheuristic
methods to the two algorithms, as suggested by
\cite{metaheuristic}. The genetic algorithm could take advantage of
metaheuristics to be more adaptive to the problem and decrease its
runtime \cite{adaptive_genetic}. The min-conflict algorithm could also
exploit metaheuristics by using tabu search to avoid returning to
already computed states \cite{russel2016artificial}.

%% \begin{figure}
%% \includegraphics[width=\textwidth]{figure_algorithms.png}
%% \caption{A plot of the results of the two algorithms.} \label{fig1}
%% \end{figure}


\section{Conclusion}
In this paper we have addressed the use of local search algorithms to
solve the N-queens optimization problem. Both genetic and
min-conflict algorithms have been described and tested. As we analyzed in the
results section, the min-conflict algorithm performs better and its
model of the problem as a constraint satisfaction problem is more
suitable for this kind of domain. On the other hand, the genetic
algorithm is more general purpose and can be also applied to domains
that are not reducible to \textit{CSP}. 

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
% \bibliographystyle{splncs04}
% \bibliography{mybibliography}
%
\begin{thebibliography}{8}

\bibitem{groups}
Powers, S.T., Penn, A.S. and Watson, R.A., 2007, September. Individual
selection for cooperative group formation. In European Conference on
Artificial Life (pp. 585-594). Springer, Berlin, Heidelberg.

\bibitem{simon}
Simon T. Powers, Social nice construction: evolutionary explanations for cooperative group forma-tion, University of Southampton, School of Electronics and Computer Science, Doctoral Thesis, 186pp, (2010)
  
\bibitem{b1}
Pfeiffer, T., Schuster, S., Bonhoeffer, S.: Cooperation and competition in the evolution of ATP-producing pathways. Science 292(5516) (2001) 504–507 

\bibitem{b2}
Pfeiffer, T., Bonhoeffer, S.: An evolutionary scenario for the
transition to undif-ferentiated multicellularity. PNAS 100(3) (2003)
1095–1098

\bibitem{b3}
Kreft, J.U.: Biofilms promote altruism. Microbiology 150 (2004)
2751–2760

\bibitem{b4}
Kreft, J.U., Bonhoeffer, S.: The evolution of groups of cooperating
bacteria and the growth rate versus yield trade-off. Microbiology 151
(2005) 637–641

\bibitem{b5}
Nowak, M.A., May, R.M.: The spatial dilemmas of
evolution. International Journal of Bifurcation and Chaos 3(1) (1993)
35–78

\bibitem{b6}
Wilson, D.S.: A theory of group selection. PNAS 72(1) (1975) 143–146 

\bibitem{b7}
Wilson, D.S.: The Natural Selection of Populations and Communities. Ben-jamin/Cummings (1980) 

\bibitem{b8}
Sober, E., Wilson, D.S.: Unto Others: The Evolution and Psychology of Unselfish Behavior. Harvard University Press, Cambridge, MA (1998) 

\bibitem{b9}
Wilson, D.S., Dugatkin, L.A.: Group selection and assortative
interactions. The American Naturalist 149(2) (1997) 336–351

\bibitem{b10}
Odling-Smee, F.J., Laland, K.N., Feldman, M.W.: Niche construction:
the ne-glected process in evolution. Monographs in population biology;
no. 37. Princeton University Press (2003)

\bibitem{b11}
Keller, L., ed.: Levels of Selection in Evolution. Monographs in behavior and ecology. Princeton University Press (1999)

\end{thebibliography}

\section{Appendix A: source code}\label{appendix}
This appendix section contains the source code of the program:
\begin{itemize}
\item Run with: \textit{python2 nqTesting.py}
\end{itemize}

\subsection{Main.java}\label{main}
\lstinputlisting[language=Java]{./src/Main.java}

\subsection{Individual.java}\label{ind}
\lstinputlisting[language=Java]{./src/Individual.java}

\subsection{IndividualFrequencies.java}\label{indfre}
\lstinputlisting[language=Java]{./src/IndividualFrequencies.java}

\subsection{GroupFrequencies.java}\label{groupfre}
\lstinputlisting[language=Java]{./src/GroupFrequencies.java}

%% \section{Appendix B: program output}\label{appendixB}
%% This appendix section contains a complete output of the program:
%\lstinputlisting{output}

\end{document}
